Package simpleAdder ; 
     
Helpers 
    /* Our helpers */ 
    caracteres_permitidos = [[32..126]-39];
    all = [0 .. 0xffff];
    numero = ['0' .. '9'] ; 
   	tab = 9;
 	cr = 13; 
 	nl = 10;
 	eol = nl | cr | cr nl; 
    sp = 32; /*Espaço */
	letra = [ ['A' .. 'Z'] + ['a' .. 'z'] ] ;
    underscore = '_' ;
    verdadeiro = 'verdadeiro';
    falso = 'falso';
    
States
  normal,comment;

    
Tokens 
    {normal} branco = eol | tab | sp;
    {normal} tabulacao = tab;
    {normal} enter = eol;
    {normal} espaco = sp;
   
 /*	Palavras reservadas  */  //palavras reservadas devem vir primeiro que id para evitar conflito 
 	{normal} programa = 'programa';
 	{normal} se = 'se';
 	{normal} senao = 'senao';
 	{normal} inicio = 'inicio';
 	{normal} fim = 'fim.';
 	{normal} enquanto = 'enquanto';
 	{normal} para = 'para';
 	{normal} avalie = 'avalie';
 	{normal} caso = 'caso';
 	{normal} leia = 'leia';
 	{normal} escreva = 'escreva';
	{normal} entao = 'entao';
	{normal} faca = 'faca';
	{normal} repita = 'repita';
	{normal} ate = 'ate';
	{normal} xor = 'xor';
	{normal} de = 'de';
	{normal} passo = 'passo';
	{normal} fim_avalie = 'fim avalie';
	{normal} fim_se = 'fim se';
	{normal} fim_para = 'fim para';
	{normal} fim_enquanto = 'fim enquanto';
	{normal} const = 'const';
	
	//Reservadas com comandos
	
  	{normal} inteiro_reservada =  'inteiro';
 	{normal} real_reservada =  'real';
   	{normal} caractere_reservada = 'caractere';
   	{normal} booleano_reservada = 'booleano';
   	
  /* 	Tipos de Comentarios 		*/
  	{normal} fim_comentario = '*/';
	{normal} comentario_de_linha = '//'[[[0..9]+[11..12]]+[14..255]]*;  //tudo menos o nl
  	{normal->comment, comment}
     comment = '/*';
	{comment} comment_end = '*/';
	{comment} comment_body = [all -['*' + '/']]*;
	{comment} star = '*';
	{comment} slash = '/';    
  	
 /* Operadores aritmeticos*/ 
	{normal} mais = '+' ; 
    {normal} menos = '-' ;
    {normal} mult = '*';
    {normal} div = '/' ; 

/* 	Operadores relacionais */
	{normal} igual = '=';
	{normal} diferente = '<>';
	{normal} maiorig = '>=';
	{normal} menorig = '<=';
	{normal} maior = '>' ;
	{normal} menor = '<' ;
	
/* 	Simbolos			*/
	{normal} abre_colchete = '[' ;
	{normal} abre_parentese = '(' ;
	{normal} fecha_colchete = ']' ;
	{normal} fecha_parentese = ')' ;
	{normal} atribuicao = ':=' ;
    {normal} doispontos = ':' ;
	{normal} pontovirgula = ';' ;
    {normal} virgula = ',';
	
/* 	Operadores boleanos 		*/
	{normal} nao = 'nao';
	{normal} ou = 'ou' ;
	{normal} e = 'e' ;
 
/*	Tipos de variaveis*/
	{normal} inteiro =  numero+;
 	{normal} real =   numero+ ',' numero+;
   	{normal} caractere = '''caracteres_permitidos''';
   	{normal} booleano = verdadeiro | falso;
	
// simbolos especiais
	{normal} string = ''' caracteres_permitidos+ ''';
	
//	Identificadores
	{normal} id = (letra (letra | underscore | numero)* ) | (underscore (letra | underscore | numero)+) ;    

Ignored Tokens
	branco,comment, comentario_de_linha;

Productions 

	 program {-> program} = programa  id  inicio declaracao* comando* fim {-> New program(id,[declaracao], [comando])};
	 
	 declaracao {-> declaracao} = {variavel} tipo doispontos decl_variavel {-> New declaracao.variavel(tipo, decl_variavel.declaracao)}  
	 							| {constante} const id valor pontovirgula	 {-> New declaracao.constante(id, valor)};
		
	 decl_variavel {-> declaracao} = {varias} var virgula decl_variavel {-> New declaracao.varias([var])}
	 							   | {unica} var pontovirgula {-> New declaracao.unica(var)};

	 comando {-> comando} = {inteiro} inteiro {-> New comando.inteiro(inteiro)};
/*	 
	 comando = var atribuicao exp pontovirgula
	 		 |{leia} leia abre_parentese decl_var_sempontov fecha_parentese pontovirgula
			 |{escreva} escreva abre_parentese decl_exp fecha_parentese pontovirgula
			 |{se} se abre_parentese exp_logica fecha_parentese entao comando+ decl_senao? fim_se pontovirgula
			 |{enquanto} enquanto abre_parentese exp_logica fecha_parentese faca comando+ fim_enquanto pontovirgula
			 |{repita} repita comando+ ate abre_parentese exp_logica fecha_parentese pontovirgula
			 |{para_sem_passo} para var de [esquerda]:inteiro ate [direita]:inteiro faca comando+ fim_para pontovirgula
			 |{para_com_passo} para var de [primeiro]:inteiro passo [segundo]:inteiro 
			   				   ate [terceiro]:inteiro faca comando+ fim_para pontovirgula
			 |{avalie} avalie abre_parentese exp fecha_parentese casos*  decl_senao_avalie pontovirgula;
			
	//Estrutura auxiliar para o se
	decl_senao = senao comando+;	
	
	//Estrutura auxiliar para o senao
	decl_senao_avalie = {com_opcional} senao doispontos comando+ fim_avalie 
	   			      | {sem_opcional} fim_avalie;
	
	//Estrutura auxiliar para o avalie
	casos = caso valor doispontos comando+;
	
	
	//Estrutura auxiliar para o leia		
	decl_var_sempontov = {varias} var virgula decl_var_sempontov 
	 			       | {unica} var;
	
	//Estrutura auxiliar para o escreva 
	decl_exp = {varias_exp} exp virgula decl_exp 
	 		 | {unica_exp} exp; 
	
	//Estrutura do exp
	
	exp_logica = {ou} exp_logica ou logica_and 
			   | {and} logica_and;
	 		   
	logica_and = {e} logica_and e logica_xor
	 		   | {xor} logica_xor;	

	logica_xor = {xor} logica_xor xor logica_neg
			   | {negacao} logica_neg;	
	
	logica_neg = {negacao} nao logica_neg
	 		   | {igualdade} logica_igualdade;
	
	logica_igualdade = {igualdade_op} [esq]:exp igual_op [dir]:exp
					 | {igualdade_parentese} logica_igualdade igual_op logica_igualdade_part  					
					 | {parentese} parentese_logica;
					 
	logica_igualdade_part = [l]: abre_parentese [esq]:exp igual_op [dir]:exp fecha_parentese;				 
					 
	igual_op = {igual} igual
			 | {diferente} diferente;
			   
	parentese_logica = {parentese} abre_parentese exp_logica fecha_parentese
					 | {um_relacional} relacionais;
					 
	relacionais = {rel} relacionais op_relacional exp
				| {um_relacional} [esq]:exp op_relacional [dir]:exp;	
	   
	op_relacional = {menor} menor
			  	  | {menorigual} menorig 
				  | {maiorigual} maiorig
				  | {maior} maior;
	
	exp = {soma} exp op_soma termo 
		| {termo} termo;
		
	op_soma = {mais} mais 
		 | {menos} menos;	

	termo = {op} termo op fator 
		 | fator;
		  
	op = {mult} mult
		|{div} div;
	
	fator = {exp} abre_parentese exp fecha_parentese 
		   | {valor} valor
		   | {var} var;	
*/	
//declaracao de variaveis, tipos e valor;

	var {-> var}= {real} real {-> New var.real(real)};
//	var = {id_unica} id; 
//	    | {vetor} id abre_colchete inteiro fecha_colchete;	 	 
 
	tipo {-> tipo} = {real_palavra} real_reservada {-> New tipo.real_palavra()}
	     		   | {inteiro_palavra} inteiro_reservada {-> New tipo.inteiro_palavra()}
			       | {caracter_palavra} caractere_reservada {-> New tipo.caracter_palavra()}
			       | {booleano_palavra} booleano_reservada {-> New tipo.booleano_palavra()};
			 
	valor {-> valor} = {char} caractere {-> New valor.char(caractere)}
				 	 | {int} inteiro {-> New valor.int(inteiro)}
				     | {float} real {-> New valor.float(real)}
				     | {booleano} booleano {-> New valor.booleano(booleano)};

Abstract Syntax Tree

	program = id declaracao* comando*;
	
	declaracao = {variavel} tipo var+
			   | {constante} id valor;
	
	comando = {inteiro} inteiro;

	var = {real} real;

	tipo = {real_palavra}  
     	 | {inteiro_palavra}  
		 | {caracter_palavra}  
		 | {booleano_palavra};
		 
	valor = {char} caractere 
		  | {int} inteiro
	      | {float} real
	      | {booleano} booleano;

//Lembrar da exceção de comentario de bloco fim errado caso troque o nome de simpleAdder
