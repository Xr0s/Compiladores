Package simpleAdder ; 
     
Helpers 
    /* Our helpers */ 
    caracteres_permitidos = [[32..126]-39];
    all = [0 .. 0xffff];
    numero = ['0' .. '9'] ; 
   	tab = 9;
 	cr = 13; 
 	nl = 10;
 	eol = nl | cr | cr nl; 
    sp = 32; /*Espaço */
	letra = [ ['A' .. 'Z'] + ['a' .. 'z'] ] ;
    underscore = '_' ;
    verdadeiro = 'verdadeiro';
    falso = 'falso';
    
States
  normal,comment;

    
Tokens 
    {normal} branco = eol | tab | sp;
    {normal} tabulacao = tab;
    {normal} enter = eol;
    {normal} espaco = sp;
   
 /*	Palavras reservadas  */  //palavras reservadas devem vir primeiro que id para evitar conflito 
 	{normal} programa = 'programa';
 	{normal} se = 'se';
 	{normal} senao = 'senao';
 	{normal} inicio = 'inicio';
 	{normal} fim = 'fim.';
 	{normal} enquanto = 'enquanto';
 	{normal} para = 'para';
 	{normal} avalie = 'avalie';
 	{normal} caso = 'caso';
 	{normal} leia = 'leia';
 	{normal} escreva = 'escreva';
	{normal} entao = 'entao';
	{normal} faca = 'faca';
	{normal} repita = 'repita';
	{normal} ate = 'ate';
	{normal} xor = 'xor';
	{normal} de = 'de';
	{normal} passo = 'passo';
	{normal} fim_avalie = 'fim avalie';
	{normal} fim_se = 'fim se';
	{normal} fim_para = 'fim para';
	{normal} fim_enquanto = 'fim enquanto';
	{normal} const = 'const';
	
	//Reservadas com comandos
	
  	{normal} inteiro_reservada =  'inteiro';
 	{normal} real_reservada =  'real';
   	{normal} caractere_reservada = 'caractere';
   	{normal} booleano_reservada = 'booleano';
   	
  /* 	Tipos de Comentarios 		*/
  	{normal} fim_comentario = '*/';
	{normal} comentario_de_linha = '//'[[[0..9]+[11..12]]+[14..255]]*;  //tudo menos o nl
  	{normal->comment, comment}
     comment = '/*';
	{comment} comment_end = '*/';
	{comment} comment_body = [all -['*' + '/']]*;
	{comment} star = '*';
	{comment} slash = '/';    
  	
 /* Operadores aritmeticos*/ 
	{normal} mais = '+' ; 
    {normal} menos = '-' ;
    {normal} mult = '*';
    {normal} div = '/' ; 

/* 	Operadores relacionais */
	{normal} igual = '=';
	{normal} diferente = '<>';
	{normal} maiorig = '>=';
	{normal} menorig = '<=';
	{normal} maior = '>' ;
	{normal} menor = '<' ;
	
/* 	Simbolos			*/
	{normal} abre_colchete = '[' ;
	{normal} abre_parentese = '(' ;
	{normal} fecha_colchete = ']' ;
	{normal} fecha_parentese = ')' ;
	{normal} atribuicao = ':=' ;
    {normal} doispontos = ':' ;
	{normal} pontovirgula = ';' ;
    {normal} virgula = ',';
	
/* 	Operadores boleanos 		*/
	{normal} nao = 'nao';
	{normal} ou = 'ou' ;
	{normal} e = 'e' ;
 
/*	Tipos de variaveis*/
	{normal} inteiro =  numero+;
 	{normal} real =   numero+ ',' numero+;
   	{normal} caractere = '''caracteres_permitidos''';
   	{normal} booleano = verdadeiro | falso;
	
// simbolos especiais
	{normal} string = ''' caracteres_permitidos+ ''';
	
//	Identificadores
	{normal} id = (letra (letra | underscore | numero)* ) | (underscore (letra | underscore | numero)+) ;    

Ignored Tokens
	branco,comment, comentario_de_linha;

Productions 

	 program {-> program} = programa  id  inicio declaracao* comando* fim {-> New program(id,[declaracao], [comando])};
	 
	 declaracao {-> declaracao} = {variaveis} tipo doispontos decl_variavel pontovirgula  {-> New declaracao.variaveis (tipo, decl_variavel)}  
	 							| {constante} const id valor pontovirgula	 {-> New declaracao.constante(id, valor)};
		
	 decl_variavel {-> decl_variavel} = {varias} var virgula decl_variavel {-> New decl_variavel.varias ( var, decl_variavel)}
	 					        	  | {unica} var {-> New decl_variavel.unica(var)};
	
	 comando {-> comando} = {atribuicao} var atribuicao exp pontovirgula { -> New comando.atribuicao (var,exp)}
	  			 		  |{leia} leia abre_parentese decl_variavel fecha_parentese pontovirgula { -> New comando.leia( decl_variavel )}      
						  |{escreva} escreva abre_parentese decl_exp fecha_parentese pontovirgula { -> New comando.escreva ( decl_exp )}
						  |{se} se abre_parentese exp_logica fecha_parentese entao /*comando+ [senao]:decl_senao? fim_se pontovirgula */ { -> New comando.se (exp_logica )}
						  ;
/*						  |{enquanto} enquanto abre_parentese exp_logica fecha_parentese faca comando+ fim_enquanto pontovirgula
						  |{repita} repita comando+ ate abre_parentese exp_logica fecha_parentese pontovirgula
						  |{para_sem_passo} para var de [esquerda]:inteiro ate [direita]:inteiro faca comando+ fim_para pontovirgula
						  |{para_com_passo} para var de [primeiro]:inteiro passo [segundo]:inteiro 
						   				   ate [terceiro]:inteiro faca comando+ fim_para pontovirgula
						 |{avalie} avalie abre_parentese exp fecha_parentese casos*  decl_senao_avalie pontovirgula;
*/ 	
	//Estrutura auxiliar para o escreva 
	decl_exp {-> decl_exp} = {varias} exp virgula decl_exp { -> New decl_exp.varias (exp,decl_exp)} 
	 		 			   | {unica} exp {-> New decl_exp.unica (exp)}
	 		 			   ; 

		
	//Estrutura auxiliar para o se
//	decl_senao { -> comando} = senao comando+ {-> comando }	;	


/*
	//Estrutura auxiliar para o senao avalie
	decl_senao_avalie = {com_opcional} senao doispontos comando+ fim_avalie 
	   			      | {sem_opcional} fim_avalie;
	
	//Estrutura auxiliar para o avalie
	casos = caso valor doispontos comando+;
	
*/
	//Estrutura do exp-logica

	exp_logica {-> exp_logica} = {ou} [esq]:exp_logica ou [dir]:logica_and {-> New exp_logica.ou ( esq.exp_logica, dir.exp_logica) } 
			   				   | {and} logica_and { -> logica_and.exp_logica};
	 		   
	logica_and {-> exp_logica} = {e} [esq]:logica_and e [dir]:logica_xor {-> New exp_logica.and (esq.exp_logica, dir.exp_logica)} 
	 		   				   | {xor} logica_xor { -> logica_xor.exp_logica};	

	logica_xor {-> exp_logica} = {xor} [esq]:logica_xor xor [dir]:logica_neg {-> New exp_logica.xor (esq.exp_logica, dir.exp_logica)} 
			   				   | {negacao} logica_neg { -> logica_neg.exp_logica};	
	
	logica_neg {-> exp_logica} = {negacao} nao logica_neg { -> New exp_logica.negacao (exp_logica)}
	 		   				   | {igualdade} logica_igualdade { -> logica_igualdade.exp_logica };
	
	logica_igualdade {-> exp_logica} = {igualdade_exp} [esq]:exp igual [dir]:exp { -> New exp_logica.igualdade_exp (esq.exp, dir.exp) }
									 | {diferente_exp} [esq]:exp diferente [dir]:exp  {-> New exp_logica.diferente_exp (esq.exp, dir.exp) }
					 				 | {igualdade_parentese} [esq]:logica_igualdade igual logica_igualdade_part {-> New exp_logica.igualdade_parentese (esq.exp_logica, logica_igualdade_part)}					
					 				 | {diferente_parentese} [esq]:logica_igualdade diferente logica_igualdade_part {-> New exp_logica.diferente_parentese (esq.exp_logica, logica_igualdade_part)}					
					 				 | {parentese} parentese_logica { -> parentese_logica.exp_logica };
					 
	logica_igualdade_part {-> logica_igualdade_part}  = {igual} [l]: abre_parentese [esq]:exp igual [dir]:exp fecha_parentese {-> New logica_igualdade_part.igual( esq.exp, dir.exp) }				 
					 					   			  | {dif} [l]: abre_parentese [esq]:exp diferente [dir]:exp fecha_parentese {-> New logica_igualdade_part.dif ( esq.exp, dir.exp) } ;
			   
	parentese_logica {-> exp_logica}  = {parentese} abre_parentese exp_logica fecha_parentese {-> New exp_logica.parentese (exp_logica) }
					 				  | {um_relacional} relacionais { -> relacionais.exp_logica} ;
					 
	relacionais {-> exp_logica} = {menor} relacionais menor relacionais_part {-> New exp_logica.menor(exp_logica, relacionais_part)}
								| {maior} relacionais maior relacionais_part {-> New exp_logica.maior(exp_logica, relacionais_part)}
								| {menorigual} relacionais menorig relacionais_part {-> New exp_logica.menorig(exp_logica, relacionais_part)}
								| {maiorigual} relacionais maiorig relacionais_part {-> New exp_logica.maiorig(exp_logica, relacionais_part)} 
								| relacionais_part { -> relacionais_part} 
								;

	relacionais_part {-> relacionais_part} = {menor} [esq]:exp menor [dir]:exp {-> New relacionais_part.menor(esq.exp, dir.exp)}
							   			| {maior} [esq]:exp maior [dir]:exp {-> New relacionais_part.maior(esq.exp, dir.exp)}
										| {menorigual} [esq]:exp menorig [dir]:exp {-> New relacionais_part.menorig(esq.exp, dir.exp)}
										| {maiorigual} [esq]:exp maiorig [dir]:exp {-> New relacionais_part.maiorig(esq.exp, dir.exp)} 
										;					
	   		

	//Estrutura do exp
	exp {-> exp} = {add} [esq]:exp mais [dir]:termo {-> New exp.add(esq.exp, dir.exp)}
				 | {sub} [esq]:exp menos [dir]:termo {-> New exp.sub(esq.exp, dir.exp)}
				 | {termo} termo {-> termo.exp};

	termo {-> exp} = {mult} [esq]:termo mult [dir]:fator {-> New exp.mult (esq.exp, dir.exp)} 
		 		   | {div} [esq]:termo div [dir]:fator {-> New exp.div (esq.exp, dir.exp)} 
		 		   | fator {-> fator.exp};
	
	fator {-> exp} = {exp} abre_parentese exp fecha_parentese {-> exp.exp}
				   | {valor} valor {-> New exp.valor(valor)}
				   | {var} var	 {-> New exp.var(var) }
				   ;
			
//declaracao de variaveis, tipos e valor;

	
	var {-> var} = {id_unica} id {-> New var.id_unica (id)} 
	    	   	 | {vetor} id abre_colchete inteiro fecha_colchete { -> New var.vetor(id,inteiro)}
	    	   	 ;	 	 
 
	tipo {-> tipo} = {real_palavra} real_reservada {-> New tipo.real_palavra()}
	     		   | {inteiro_palavra} inteiro_reservada {-> New tipo.inteiro_palavra()}
			       | {caracter_palavra} caractere_reservada {-> New tipo.caracter_palavra()}
			       | {booleano_palavra} booleano_reservada {-> New tipo.booleano_palavra()};
			 
	valor {-> valor} = {char} caractere {-> New valor.char(caractere)}
				 	 | {int} inteiro {-> New valor.int(inteiro)}
				     | {float} real {-> New valor.float(real)}
				     | {booleano} booleano {-> New valor.booleano(booleano)};

Abstract Syntax Tree

	program = id declaracao* comando*;
	
	declaracao = {variaveis} tipo decl_variavel
			   | {constante} id valor;
	
	decl_variavel = {varias} var decl_variavel
	 		      | {unica} var ;
	
	comando = {atribuicao} var exp  
			| {leia} decl_variavel
			| {escreva} decl_exp 
			| {se} exp_logica
			;
	
	decl_exp = {varias} exp decl_exp
	 		 | {unica} exp ;
	
	exp_logica = {ou} [esq]:exp_logica [dir]:exp_logica
			   | {and} [esq]:exp_logica [dir]:exp_logica
			   | {xor} [esq]:exp_logica [dir]:exp_logica
			   | {menor} exp_logica relacionais_part 
			   | {maior} exp_logica relacionais_part 
 			   | {menorigual} exp_logica relacionais_part 
			   | {maiorigual} exp_logica relacionais_part  
			   | relacionais_part			    
			   | {igualdade_exp} [esq]:exp [dir]:exp 
			   | {diferente_exp} [esq]:exp [dir]:exp
			   | {igualdade_parentese} exp_logica logica_igualdade_part
			   | {diferente_parentese} exp_logica logica_igualdade_part				
			   | {parentese} exp_logica 
			   | {negacao} exp_logica
			   ;
					 
	logica_igualdade_part = {igual} [esq]:exp [dir]:exp  
					 	  | {dif} [esq]:exp [dir]:exp 
						  ;
			   
	relacionais_part = {menor} [esq]:exp [dir]:exp 
			   		 | {maior} [esq]:exp [dir]:exp 
	 			     | {menorigual} [esq]:exp [dir]:exp 
				     | {maiorigual} [esq]:exp [dir]:exp  
					 ;	
	exp = {add} [esq]:exp [dir]:exp
		| {sub} [esq]:exp [dir]:exp
		| {mult} [esq]:exp [dir]:exp
		| {div} [esq]:exp [dir]:exp
		| {valor} valor
		| {var} var
		| exp
		;
		
	var = {id_unica} id  
	    | {vetor} id inteiro
	    ;
	tipo = {real_palavra}  
     	 | {inteiro_palavra}  
		 | {caracter_palavra}  
		 | {booleano_palavra};
		 
	valor = {char} caractere 
		  | {int} inteiro
	      | {float} real
	      | {booleano} booleano;

//Lembrar da exceção de comentario de bloco fim errado caso troque o nome de simpleAdder
